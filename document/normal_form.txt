说明：来自lihaoran同学整理，感谢
注意：
1.区分清楚“包含码”和“包含主属性”
a)码==候选码
b)候选码可能不止一个
c)候选码包含多个主属性,主属性不一定是候选码
2.传递函数依赖的定义一定要清楚：
a)A->B->C   C对A传递函数依赖
b)A<->B->C  不是
c)A->B<->C  C对A传递函数依赖

Armstrong公理系统（用于查找候选码）：
1.自反律：若属性集Y 包含于属性集X，属性集X 包含于U，则X→Y 在R 上成立。(此处X→Y是平凡函数依赖) 。
即：AB->A, AB->B。
2.增广律：若X→Y 在R 上成立，且属性集Z 包含于属性集U，则XZ→YZ 在R 上成立。
即：若A->B,则AC->BC
3.传递律：若X→Y 和 Y→Z在R 上成立，则X →Z 在R 上成立。
即：若A->B->C，则A->C
4.合并规则：若X→Y，X→Z同时在R上成立，则X→YZ在R上也成立。
即：若A->B且A->C，则A->BC
5.分解规则：若X→W在R上成立，且属性集Z包含于W，则X→Z在R上也成立。
即：若A->BC，则A->B且A->C
6.伪传递规则：若X→Y在R上成立，且WY→Z，则XW→Z。
即：若A->B，BC->D，则AC->D（因为AC->BC->D）

范式题解题步骤：
1.找到所有候选码，确定主属性、非主属性（参考Armstrong公理系统）。
2.检查每个箭头的左边，看是否都包含候选码。如果满足则为BCNF。否则排除BCNF。
3.检查是否存在非主属性，如果不存在则必然为3NF。
4.检查非主属性对码的传递函数依赖。注意1、2。如果不存在传递依赖则有可能是3NF，待定。
5.检查非主属性对码的部分函数依赖。注意1。判断每个候选码的每个真子集（如果候选码仅包含一个属性，则不存在真子集；候选码包含两个属性，即分别判断每个属性；候选码一般不会超过两个属性），能否直接或者传递的确定某个非主码，若可以确定，则存在部分函数依赖，排除2NF。若不存在部分函数依赖，则满足2NF。
6.如果4可能是3NF且满足2NF，则为3NF。若不满足2NF，则最差情况一定是1NF，因为出题时属性组一定是原子的，否则会在题目中特别说明，会很明显。



参考网页《数据库闭包和候选码求解方法》：
http://www.cnblogs.com/gulvzhe/archive/2013/05/24/3096913.html
摘抄候选码求解方法如下（需要结合Armstrong公理系统使用）：
闭包概念
　　以下是写的比较科学规范的闭包求解方法，设X和Y均为关系R的属性集的子集，F是R上的函数依赖集，若对R的任一属性集B，一旦X→B，必有B⊆Y，且对R的任一满足以上条件的属性集Y1 ，必有Y⊆Y1，此时称Y为属性集X在函数依赖集F下的闭包，记作X＋。 
　　计算关系R的属性集X的闭包的步骤如下： 
　　第一步：设最终将成为闭包的属性集是Y，把Y初始化为X； 
　　第二步：检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将其加入到Y中； 
　　第三步：重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋
      例（1）：   设有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)+
        解:  (1) 令X={AE}，X(0)=AE
              (2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE， 显然 X(1)≠X(0).
              (3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AE)+=ACDEI。
　　　说白话一点：闭包就是由一个属性直接或间接推导出的所有属性的集合。
         例如：f={a->b，b->c，a->d，e->f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}
候选码的求解理论和算法
　　对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：
　　　　L类  仅出现在函数依赖左部的属性。
　　　　R 类  仅出现在函数依赖右部的属性。
　　　　N 类  在函数依赖左右两边均未出现的属性。
　　　　LR类  在函数依赖左右两边均出现的属性。
　　定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的任一候选码的成员。
　　推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X+包含了R的全部属性；则X必为R的唯一候选码。
　　例（2）：设有关系模式R（A，B，C，D），其函数依赖集F={D→B，B →D，AD →B，AC →D}，求R的所有候选码。
　　       解：考察F发现，A，C两属性是L类属性，所以AC必是R的候选码成员，又因为（AC）+=ABCD，所以AC是R的唯一候选码。
　　定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X不在任何候选码中。
　　定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X必包含在R的任一候选码中。
　　推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X+包含了R的全部属性；则X是R的唯一候选码。

7.
1. R(ABCD), F=(B->D, AB->C)

1)AB为候选码
A、B为主属性，C、D为非主属性；
2)检查B->D, B不是码（AB才是码），所以不是BCNF；
3)存在非主属性，可能为3NF；
4)明显不存在对码的传递函数依赖，可能为3NF；
5)AB(码)->D && B->D，所以非主属性D存在对码AB的部分函数依赖，不是2NF；
6)所以为1NF。

2. R(ABCDE),F=(AB->CE, E->AB,C->D)

1)AB->CE => AB->E，AB->C（分解）；
AB->E , E->AB => E<->AB；
E<->AB->C->D；
AB/E为候选码，A、B、E为主属性，C、D为非主属性；
2)检查C->D, C不是码，排除BCNF；
3)存在非主属性，可能为3NF；
4)存在对码AB的传递函数依赖AB->C->D，排除3NF；
5)由E<->AB->C->D可知不存在对码的部分函数依赖，满足2NF；
6)所以是2NF。

3. R(ABCD), F(B->D, D->B, AB->C)

1)A(B<->D)->C
候选码为AB、AD；
主属性为A、B、D， 非主属性为C；
2)考察B->D，B不是候选码，排除BCNF；
3)存在非主属性，可能为3NF；
4)AD->C，AB->C，不存在对码的传递依赖，可能为3NF；
5)所有码的真子集(A/B/C)均不能直接或间接的决定C，不存在对码的部分依赖，满足2NF；
6)所以为3NF。

4. R(ABC), F(A->B, B->A, C->A)

1)C->A<->B
候选码为C；
主属性为C，非主属性为A、B；
2)考察A->B，A不是候选码，排除BCNF；
3)存在非主属性，可能为3NF；
4)C->A<->B存在B对码C的传递依赖，参考“注意-2-C” ，排除3NF；
5)明显不存在对码的部分依赖，满足2NF；
6)所以为2NF。

5. R(ABC), F(A->B, B->A, A->C)

1)B<->A->C；
候选码为A、B；
主属性为A、B，非主属性为C；
2)决定因素只有A、B，符合BCNF条件：所有的决定因素都包含码；所以为BCNF。

6. R(ABCD), F=(A->C, D->B)

1)候选码为AD；
主属性为A、D，非主属性为C、B；
2)考察A->C，A不包含码，排除BCNF；
3)存在非主属性，可能为3NF；
4)不存在对码的传递依赖，可能为3NF；
5)考察AD->A->C,所以存在C对码AD的部分依赖，排除2NF；
6)所以为1NF。（存在异议，答案有人记得是3NF，最后经过大家的讨论认为是1NF没错）

7. R(ABCD), F=(A->C, CD->B)

1)AD->CD->{C，B}
候选码为AD；
主属性为A、D，非主属性为B、C；
2)考察A->C，A不包含码，排除BCNF；
3)存在非主属性，可能为3NF；
4)考察AD->B，AD->CD->B,存在B对码AD的传递依赖，排除3NF；
5)考察AD->B，不存在A->B或D->B，即不存在非主属性B对码AD的部分依赖；
考察AD->C，存在A->C，即存在非主属性C对码AD的部分依赖，排除2NF；
6)所以为1NF。
